<!DOCTYPE html>
<html>
  <head>
    <script>
      var score; // 변수의 선언
      score = 80; // 값의 할당

      //   변수 호이스팅.
      console.log(foo); //undifined
      var foo = 123;
      console.log(foo); //123
      {
        var foo = 456;
      }
      console.log(foo); //456

      var on = 123;
      console.log(on);
      {
        on = 456;
      }
      console.log(on);
    </script>
  </head>

  <body>
    <pre>
      객체는 데이터와 그 데이터에 관련한 동작을 모두 포함할 수 있는 개념적 존재이다. 달리말해, 이름과 값을 가지는 데이터를 의미하는 프로퍼티와 동작을 
      의미하는 메소드를 초함할 수 있는 독립적 주체이다. 자바스크립트 객체 기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.
      원시탑일을 제외한 나머지 값들은 모두 객체이다. 또한 객체는 pass-by-reference방식으로 전잘, 참조에 의한 전달로 전달. 
      </pre
    >

    <pre>

        변수 
        변수는 프로그램에서 사용되는 데이터를 일정 긴간 동안 기억하여 필요한 때에 다시 사용하기 위해 데이터에 고유의 이름인 식별자를 명시한 것이다. 
        변수에 명시한 고유한 식별자를 변수명이라 하고 변수로 참조할 수 있는 데이터를 변수값이라 한다. 

        식별자는 어떤 대상을 유일하게 식별할 수 있는 이름을 말한다. 식별자에는 변수명, 함수명, 프로퍼티명, 클래스명 등이 있다. 
        변수는 var,let,const 키워드를 사용하여 선언하고, 할당 연산자를 사용해 값을 할당한다. 그리고 식별자인 변수명을 사용해 변수에 저장된
        값을 참조한다. 

        사람을 고유한 이름으로 구별하듯이 변수도 사람이 이해할 수 있는 언어로 지정한 고유한 식별자에 의해 구별하여 참조할 수 있다.
        데이터는 메모리에 저장되어 있다. 메모리에 저장된 데이터를 참조하려면, 데이터가 저장된 메모리 상의 주소를 알아야 한다. 
        식별자는 데이터가 저장된 메모리 상의 주소를 기억한다. 따라서 식별자를 통해 메모리에 저장된 값을 참조 할 수 있다. 또한 변수명을 통해
        데이터의 의미를 명확히 할 수 있어 코드의 가독성이 좋아지는 효과가 있다. 

        var 키워드로 선언한 변수는 중복 선언이 가능하다. 다시 말해 변수명이 같은 변수를 중복해 선언해도 에러가 발생하지 않는다. 
        만약 동일한 변수명이 선언되어 있는 것을 모르고 변수를 중복 선언했다면 의도치 않게 변수의 값을 변경하는 부작용을 발생시킨다.
        따라서 변수의 중복 선언은 문법적으로 허용되지만, 사용하지 않는 것이 좋다. 
    </pre>

    <pre>
        자바스크립트는 동적타입 언어이다. 이것은 변수의 타입지정없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결정될 것이라는 뜻이다.
        따라서 같은 변수에 여러 타입의 값을 할당할 수 있다. 이를 동적 타이핑이라고 한다. 

    </pre>

    <pre>
        var 키워드를 사용하여 선언한 변수는 중복 선언이 가능하기 때문에 위의 코드는 문법적으로 문제가 없다. 

        변수 foo는 아직 선언되지 않았기 때문에 에러가 발생할 것 같지만, undifined가 출력된다.
        c-family언어와 달리 자바스크립트의 특징으로 무든 선언문은 호이스팅되기 때문이다. 
        호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 scope의 선두로 옮겨진 것 처럼 동작하는 특성을 말한다. 
        즉 자바스크립트는 모든 선언문(let,var, const,function,function*,class)이 선언되기 이전에 참조 가능하다. 
        변수가 어떻게 생성되며 호이스팅은 어떻게 이루어지는 좀 더 자세히 살펴보자. 변수는 3단계에 걸쳐 생성된다. 자세한 내용은 excution context을
        참조하기 바란다. 
    </pre>

    <pre>
        선언단계 : 변수 객체에 변수를 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 
        초기화 단계 : 변수 객체에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undifined로 초기화 된다.
        할당 단계 : undifined로 초기화된 변수에 실제값을 할당한다. 

        * var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후
        undifined로 초기화 된다. 따라서 변수 선언문 이전에 변수에 접근하여도 variable object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 
        다만 undifined를 반환한다. 이러한 현수를 variable hoisting이라고 한다. 변수 호이스팅. 

        자바스크립트의 변수는 block level scope를 가지지 않고 함수 레벨 스코프 갖는다. ecma6에서 도입된 let,const 키워드를 사용하면
        블록 레벨 스코프를 사용할 수 있다. 자세한 내용은 scope를 참조하기 바란다. 


        function-level-scope(함수 레벨 스코프): 함수 내에 선언된 변수는 함수내에서만 유효하며(자바처럼) 함수 외부에서는 참조 할 수 없다. 
        즉 함수내부에서 선언한 변수는 지역변수이며, 함수 외부에서 선언한 변수는 모두 전역 변수이다. 

        block-level-scope: 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 

        따라서 코드 블록 내의 변수 foo는 전역변수이므로, 전역에 선언된 변수 foo에 할당된 값을 재할당하기 때문에 456이다. 
    </pre>

    <pre>
        var 키워드로 선언된 변수의 문제점. 

        es5에서 변수를 선언할 수 있는 유일한 벙법은 var키워드를 사용하는 것이다. var 키워드로 선언된 변수는 아래와 같은 특징을 갖는다. 
        이는 다른 언어와는 차별되는 특징으로 주의를 기울이지 않으면 심각한 문제를 가짐. 
        1. 함수 레벨 스코프 
        - 전역 변수 남발 
        -for loop 초기화식에서 사용하 변수를 for loop 외부 또는 전역에서 참조할 수 있다. 

        2. var 키워드 생략 허용. 
        -의도하지 않은 변수의 전역화 .

        3. 변수 호이스팅 
        변수을 선언하기 전에 참조가 가능하다. 

        대부분의 문제는 전역변수로 인해 발생한다. 전역변수는 간단한 애플리케이션의 경우, 사용이 편리한 면이 있지만 불가피한 상황을 제외하고 
        사용을 억제해야 한다. 전역 변수는 유효범위(scope)가 넓어서 어디에서 사용될지 파악하기 어려움. 이는 의도치 않은 변수의 변경이 발생할
        가능성을 중가. 또한 함수와 상호 의존하는 등 부수효과가 있을 수 있어서 복잡성 증가한다. 변수의 유효범위는 좁을 수 록 좋다. 
        이러한 단점을 보안하기 위해 let, const키워드를 도입. 
        
    </pre>
  </body>
</html>
